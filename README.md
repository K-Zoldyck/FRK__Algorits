![Banner Algorithms](./assets/images/algorithms.png)
# 🧠 algorithms-js

> Um repositório dedicado aos algoritmos que eu estudei! 🚀

Se você gosta de resolver problemas e aprimorar suas habilidades em JavaScript, você está no lugar certo! Aqui você vai encontrar diversos algoritmos que fui aprendendo e implementando durante meus estudos.

## 📁 Estrutura do Projeto

```textplain
algorithms-js/
├── algorithms/
│   ├── sorting/
│   │   ├── [algoritmo]/
│   │   │   ├── index.js
│   │   │   └── README.md
│   │   ├── [algoritmo]/
│   │   │   ├── index.js
│   │   │   └── README.md
│   │   └── ...
│   ├── searching/
│   │   ├── [algoritmo]/
│   │   │   ├── index.js
│   │   │   └── README.md
│   │   ├── [algoritmo]/
│   │   │   ├── index.js
│   │   │   └── README.md
│   │   └── ...
│   └── ...
├── tests/
│   ├── algorithms/
│   │   ├── sorting/
│   │   │   ├── [algoritmo].test.js
│   │   │   └── ...
│   │   ├── searching/
│   │   │   ├── [algoritmo].test.js
│   │   │   └── ...
│   │   └── ...
│   └── ...
├── .gitignore
├── jest.config.js
├── LICENSE
├── package.lock.json
├── package.json
└── README.md
```

## 📜 Como funciona?

Cada algoritmo estará em uma pasta específica, de acordo com sua categoria, para facilitar o entendimento e a organização. Além disso, você pode ver a explicação do funcionamento de cada algoritmo nos comentários do código ou em arquivos de documentação que acompanham o código.

## 🔍 O que é Big O Notation?

Big O Notation é uma maneira de descrever a eficiência de um algoritmo, principalmente no que diz respeito ao tempo de execução ou uso de memória, à medida que o tamanho da entrada (n) aumenta. Ela ajuda a entender como um algoritmo escala e como se comporta em diferentes cenários.

Aqui estão alguns dos termos comuns usados em Big O:

- **O(1)** - Tempo constante: O tempo de execução não depende do tamanho da entrada.
- **O(log n)** - Logaritmo: O tempo de execução cresce lentamente à medida que o tamanho da entrada aumenta.
- **O(n)** - Linear: O tempo de execução cresce proporcionalmente ao tamanho da entrada.
- **O(n log n)** - Log-linear: Comum em algoritmos de ordenação eficientes como Merge Sort e Quick Sort.
- **O(n^2)** - Quadrático: O tempo de execução aumenta exponencialmente com o aumento da entrada. Exemplo: Bubble Sort.
- **O(2^n)** - Exponencial: O tempo de execução dobra com cada aumento da entrada. Exemplo: Algoritmos de recursão complexa.
- **O(n!)** - Fatorial: Usado em problemas de permutação. Extremamente ineficiente para grandes entradas.

A notação Big O nos permite comparar a eficiência de diferentes algoritmos de forma independente do hardware ou da implementação específica.

## 🛠️ Tecnologias

- JavaScript 🟨

## 🤝 Contribuições

Contribuições são super bem-vindas! 🎉 Se você deseja adicionar um novo algoritmo, corrigir algum bug ou melhorar a performance de algum código, siga os passos abaixo:

1. Faça um fork do projeto 🍴
2. Crie uma branch com a sua feature (`git checkout -b feature/nome-da-feature`) 🌱
3. Commit suas mudanças (`git commit -m 'feat: Adicionado novo algoritmo'`) ✅
4. Faça um push da branch (`git push origin feature/nome-da-feature`) 🚀
5. Abra um Pull Request 📩

## 📚 Recursos úteis

- [MDN JavaScript Reference](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference) 📘
- [JavaScript Info](https://javascript.info/) 💡

---

Vamos juntos construir um repositório incrível de algoritmos em JavaScript! 💻✨
